/*
 * CTK - The Cell Tool Kit Library
 * http://ctk-dev.sourceforge.net/
 * http://cell.fixstars.com/ctk/
 *
 * Copyright (C) 2006-2008 Fixstars Corp.
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License,
 * or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#ifndef _CTK_SPE_LIBSPE2_H
#define _CTK_SPE_LIBSPE2_H
/**
 * @file ctk_spe-libspe2.h
 * @brief Definitions for Libspe2-dependent CTK SPE code
 */

#include <stdbool.h>
#include <libspe2.h>
#include <pthread.h>
#include "ctk_env.h"

/* for libspe2-2.0.0 work around */
#if defined(SPE_RUN_USER_REGS) && !defined(SPE_TAG_ALL)
# define LIBSPE2_VERSION   200
#elif defined(SPE_CALLBACK_NEW)
# define LIBSPE2_VERSION   202
#else
# define LIBSPE2_VERSION   201
#endif

/* the internal flag indicating if we can access problem state registers */
extern bool can_access_ps_flag;

typedef struct ctk_spe_context_body {
    /* common part */
    unsigned int m_type;
    unsigned int m_counter;
    unsigned int m_status;
    ctk_env_t *m_env;
    pthread_mutex_t m_status_lock;
    bool m_stopped;

    /* private part */
    spe_context_ptr_t m_context;
    spe_program_handle_t *m_handle;
#if (LIBSPE2_VERSION == 200)
    pthread_mutex_t m_context_lock;
#endif /* LIBSPE2_VERSION == 200 */
} ctk_spe_context_body_t;

#define _CTK_SPE_NATIVE(spe)      ((spe)->m_context)

typedef spe_program_handle_t _ctk_spe_program_t;
typedef ctk_spe_context_body_t  *_ctk_spe_context_t;

/*----------------------------------------------------------------------*/
/* XXX: the below code is a quick-hack to work-around libspe2-2.0.0 */

#if LIBSPE2_VERSION == 200

enum fd_name { FD_MBOX, FD_MBOX_STAT, FD_IBOX, FD_IBOX_STAT, FD_WBOX, FD_WBOX_STAT, FD_SIG1, FD_SIG2, FD_MFC, FD_MSS, NUM_MBOX_FDS };

#define PSMAP_SIZE			0x20000   /* 128K (in bytes) */
#define MFC_SIZE			0x1000
#define MSS_SIZE			0x1000
#define CNTL_SIZE			0x1000
#define SIGNAL_SIZE			0x1000

struct spe_context_base_priv {
	/* SPE Group base directory fd */
	int		fd_grp_dir;
	
	/* SPE SPUFS base dir fd*/
	int fd_spe_dir;
	
	/* SPE Program execution and environment flags */
	unsigned int    flags;
	
	/* SPE Mailbox and Signal fds */
	int spe_fds_array[NUM_MBOX_FDS];
	int spe_fds_refcount[NUM_MBOX_FDS];
	
	/* SPE MFC Unit fd */
	//int	fd_mfc;
	
	/* event pipes for speevent library */
	int ev_pipe[2];
	
	/* Base Addresses of memory mapped SPE areas */
	void	*psmap_mmap_base;
	void	*mem_mmap_base;
	void	*mfc_mmap_base;
	void	*mssync_mmap_base;
	void	*cntl_mmap_base;
	void	*signal1_mmap_base;
	void	*signal2_mmap_base;
	
	/* Last spu_run return code, for example stop and signal code */
	unsigned int 	stop_reason;
	
	/* Last spu_run system call status code */
	unsigned int 	stop_status;
	
	/* SPE program entry point generated by elf_load() */
	int		entry;
};
#endif /* LIBSPE2_VERSION == 200 */


#endif /* _CTK_SPE_LIBSPE2_H */
